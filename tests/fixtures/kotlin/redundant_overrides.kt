// Test fixture: Redundant override patterns
package com.example.fixtures.overrides

// Case 1: Redundant override - only calls super
open class BaseActivity {
    open fun onCreate() {
        println("BaseActivity.onCreate")
    }

    open fun onDestroy() {
        println("BaseActivity.onDestroy")
    }

    open fun onResume() {
        println("BaseActivity.onResume")
    }
}

class MainActivity : BaseActivity() {
    // DEAD: Redundant - only calls super
    override fun onDestroy() {
        super.onDestroy()
    }

    // NOT redundant - adds behavior
    override fun onCreate() {
        super.onCreate()
        println("MainActivity setup")
    }

    // NOT redundant - adds behavior before super
    override fun onResume() {
        println("Before resume")
        super.onResume()
    }
}

// Case 2: Interface with default implementation
interface Clickable {
    fun onClick() {
        println("Default click")
    }

    fun onLongClick(): Boolean {
        return false
    }
}

class Button : Clickable {
    // DEAD: Redundant - same as default
    override fun onClick() {
        super.onClick()
    }

    // NOT redundant - different behavior
    override fun onLongClick(): Boolean {
        println("Long clicked!")
        return true
    }
}

// Case 3: Abstract class implementation
abstract class AbstractProcessor {
    abstract fun process(data: String): String

    open fun validate(data: String): Boolean {
        return data.isNotEmpty()
    }

    open fun log(message: String) {
        println(message)
    }
}

class ConcreteProcessor : AbstractProcessor() {
    // Required - abstract method
    override fun process(data: String): String {
        return data.uppercase()
    }

    // DEAD: Redundant - only calls super
    override fun log(message: String) {
        super.log(message)
    }

    // NOT redundant - different logic
    override fun validate(data: String): Boolean {
        return data.length > 3
    }
}

// Case 4: Multiple inheritance levels
open class GrandParent {
    open fun action() {
        println("GrandParent")
    }
}

open class Parent : GrandParent() {
    override fun action() {
        println("Parent")
        super.action()
    }
}

class Child : Parent() {
    // DEAD: Redundant - only calls super
    override fun action() {
        super.action()
    }
}

// Case 5: Override with different visibility (NOT redundant)
open class VisibilityBase {
    protected open fun internalMethod() {
        println("Internal")
    }
}

class VisibilityDerived : VisibilityBase() {
    // NOT redundant - changes visibility to public
    public override fun internalMethod() {
        super.internalMethod()
    }
}

// Case 6: Override with annotations (NOT redundant)
open class AnnotatedBase {
    open fun method() {
        println("Base method")
    }
}

class AnnotatedDerived : AnnotatedBase() {
    // NOT redundant - adds annotation
    @Deprecated("Use newMethod instead")
    override fun method() {
        super.method()
    }
}

// Case 7: Data class - equals/hashCode/toString
open class DataBase {
    open fun customMethod(): String = "base"
}

data class DataDerived(val value: String) : DataBase() {
    // Generated by data class - check if redundant
    override fun customMethod(): String {
        return super.customMethod()  // DEAD: Redundant
    }
}

// Case 8: Kotlin property override
open class PropertyBase {
    open val name: String = "Base"
    open var count: Int = 0
}

class PropertyDerived : PropertyBase() {
    // NOT redundant - different value
    override val name: String = "Derived"

    // DEAD: Redundant getter (if only returns super)
    override var count: Int
        get() = super.count
        set(value) { super.count = value }
}

// Case 9: Companion object pattern
open class CompanionBase {
    open fun getInstance(): CompanionBase = this
}

class CompanionDerived : CompanionBase() {
    // DEAD: Redundant
    override fun getInstance(): CompanionBase {
        return super.getInstance()
    }

    companion object {
        fun create(): CompanionDerived = CompanionDerived()
    }
}

fun main() {
    val activity = MainActivity()
    activity.onCreate()
    activity.onResume()
    activity.onDestroy()

    val button = Button()
    button.onClick()
    println(button.onLongClick())

    val processor = ConcreteProcessor()
    println(processor.process("test"))
    println(processor.validate("test"))
    processor.log("message")

    val child = Child()
    child.action()

    val vis = VisibilityDerived()
    vis.internalMethod()

    val ann = AnnotatedDerived()
    ann.method()

    val data = DataDerived("value")
    println(data.customMethod())

    val prop = PropertyDerived()
    println(prop.name)
    prop.count = 5
    println(prop.count)

    val comp = CompanionDerived.create()
    println(comp.getInstance())
}
